{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nexport default class InteractionManager {\n  // Private becaues of singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  constructor() {\n    _defineProperty(this, \"waitForRelations\", new Map());\n    _defineProperty(this, \"simultaneousRelations\", new Map());\n  }\n  configureInteractions(handler, config) {\n    this.dropRelationsForHandlerWithTag(handler.getTag());\n    if (config.waitFor) {\n      const waitFor = [];\n      config.waitFor.forEach(otherHandler => {\n        // New API reference\n        if (typeof otherHandler === 'number') {\n          waitFor.push(otherHandler);\n        } else {\n          // Old API reference\n          waitFor.push(otherHandler.handlerTag);\n        }\n      });\n      this.waitForRelations.set(handler.getTag(), waitFor);\n    }\n    if (config.simultaneousHandlers) {\n      const simultaneousHandlers = [];\n      config.simultaneousHandlers.forEach(otherHandler => {\n        if (typeof otherHandler === 'number') {\n          simultaneousHandlers.push(otherHandler);\n        } else {\n          simultaneousHandlers.push(otherHandler.handlerTag);\n        }\n      });\n      this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n    }\n  }\n  shouldWaitForHandlerFailure(handler, otherHandler) {\n    const waitFor = this.waitForRelations.get(handler.getTag());\n    if (!waitFor) {\n      return false;\n    }\n    let shouldWait = false;\n    waitFor.forEach(tag => {\n      if (tag === otherHandler.getTag()) {\n        shouldWait = true;\n        return; //Returns from callback\n      }\n    });\n\n    return shouldWait;\n  }\n  shouldRecognizeSimultaneously(handler, otherHandler) {\n    const simultaneousHandlers = this.simultaneousRelations.get(handler.getTag());\n    if (!simultaneousHandlers) {\n      return false;\n    }\n    let shouldRecognizeSimultaneously = false;\n    simultaneousHandlers.forEach(tag => {\n      if (tag === otherHandler.getTag()) {\n        shouldRecognizeSimultaneously = true;\n        return;\n      }\n    });\n    return shouldRecognizeSimultaneously;\n  }\n  shouldRequireHandlerToWaitForFailure(_handler, _otherHandler) {\n    //TODO: Implement logic\n    return false;\n  }\n  shouldHandlerBeCancelledBy(_handler, _otherHandler) {\n    //TODO: Implement logic\n    return false;\n  }\n  dropRelationsForHandlerWithTag(handlerTag) {\n    this.waitForRelations.delete(handlerTag);\n    this.simultaneousRelations.delete(handlerTag);\n  }\n  reset() {\n    this.waitForRelations.clear();\n    this.simultaneousRelations.clear();\n  }\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new InteractionManager();\n    }\n    return this.instance;\n  }\n}\n_defineProperty(InteractionManager, \"instance\", void 0);","map":{"version":3,"names":["InteractionManager","constructor","_defineProperty","Map","configureInteractions","handler","config","dropRelationsForHandlerWithTag","getTag","waitFor","forEach","otherHandler","push","handlerTag","waitForRelations","set","simultaneousHandlers","simultaneousRelations","shouldWaitForHandlerFailure","get","shouldWait","tag","shouldRecognizeSimultaneously","shouldRequireHandlerToWaitForFailure","_handler","_otherHandler","shouldHandlerBeCancelledBy","delete","reset","clear","getInstance","instance"],"sources":["/Users/solomon-moulang-lewis/Documents/University/Year 2/Term 2/User interface design/soen357Project/client/node_modules/react-native-gesture-handler/lib/module/web/tools/InteractionManager.ts"],"sourcesContent":["import GestureHandler from '../handlers/GestureHandler';\nimport { Config, Handler } from '../interfaces';\n\nexport default class InteractionManager {\n  private static instance: InteractionManager;\n  private readonly waitForRelations: Map<number, number[]> = new Map();\n  private readonly simultaneousRelations: Map<number, number[]> = new Map();\n\n  // Private becaues of singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  public configureInteractions(handler: GestureHandler, config: Config) {\n    this.dropRelationsForHandlerWithTag(handler.getTag());\n\n    if (config.waitFor) {\n      const waitFor: number[] = [];\n      config.waitFor.forEach((otherHandler: Handler): void => {\n        // New API reference\n        if (typeof otherHandler === 'number') {\n          waitFor.push(otherHandler);\n        } else {\n          // Old API reference\n          waitFor.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.waitForRelations.set(handler.getTag(), waitFor);\n    }\n\n    if (config.simultaneousHandlers) {\n      const simultaneousHandlers: number[] = [];\n      config.simultaneousHandlers.forEach((otherHandler: Handler): void => {\n        if (typeof otherHandler === 'number') {\n          simultaneousHandlers.push(otherHandler);\n        } else {\n          simultaneousHandlers.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n    }\n  }\n\n  public shouldWaitForHandlerFailure(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const waitFor: number[] | undefined = this.waitForRelations.get(\n      handler.getTag()\n    );\n    if (!waitFor) {\n      return false;\n    }\n\n    let shouldWait = false;\n\n    waitFor.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldWait = true;\n        return; //Returns from callback\n      }\n    });\n\n    return shouldWait;\n  }\n\n  public shouldRecognizeSimultaneously(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const simultaneousHandlers: number[] | undefined =\n      this.simultaneousRelations.get(handler.getTag());\n    if (!simultaneousHandlers) {\n      return false;\n    }\n\n    let shouldRecognizeSimultaneously = false;\n\n    simultaneousHandlers.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldRecognizeSimultaneously = true;\n        return;\n      }\n    });\n\n    return shouldRecognizeSimultaneously;\n  }\n\n  public shouldRequireHandlerToWaitForFailure(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    //TODO: Implement logic\n    return false;\n  }\n\n  public shouldHandlerBeCancelledBy(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    //TODO: Implement logic\n    return false;\n  }\n\n  public dropRelationsForHandlerWithTag(handlerTag: number): void {\n    this.waitForRelations.delete(handlerTag);\n    this.simultaneousRelations.delete(handlerTag);\n  }\n\n  public reset() {\n    this.waitForRelations.clear();\n    this.simultaneousRelations.clear();\n  }\n\n  public static getInstance(): InteractionManager {\n    if (!this.instance) {\n      this.instance = new InteractionManager();\n    }\n\n    return this.instance;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}