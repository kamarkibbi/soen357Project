{"ast":null,"code":"/* eslint-disable eslint-comments/no-unlimited-disable */\n\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\nclass DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n  shouldFailUnderCustomCriteria(_ref, _ref2) {\n    let {\n      x,\n      y,\n      deltaX,\n      deltaY\n    } = _ref;\n    let {\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    } = _ref2;\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({\n        x,\n        y\n      })) {\n        return true;\n      }\n    }\n    return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);\n  }\n  transformNativeEvent(_ref3) {\n    let {\n      center: {\n        x,\n        y\n      }\n    } = _ref3;\n    // @ts-ignore FIXME(TS)\n    const rect = this.view.getBoundingClientRect();\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top\n    };\n  }\n  isGestureEnabledForEvent(_ref4, _recognizer, _ref5) {\n    let {\n      minPointers,\n      maxPointers,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    } = _ref4;\n    let {\n      maxPointers: pointerLength,\n      center,\n      deltaX,\n      deltaY\n    } = _ref5;\n    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n    if (this.shouldFailUnderCustomCriteria({\n      ...center,\n      deltaX,\n      deltaY\n    }, {\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    }) ||\n    // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n    // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n    !validPointerCount && this.isGestureRunning) {\n      return {\n        failed: true\n      };\n    }\n    return {\n      success: validPointerCount\n    };\n  }\n}\nexport default DiscreteGestureHandler;","map":{"version":3,"names":["GestureHandler","TEST_MAX_IF_NOT_NAN","DiscreteGestureHandler","isDiscrete","shouldEnableGestureOnSetup","shouldFailUnderCustomCriteria","_ref","_ref2","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","transformNativeEvent","_ref3","center","rect","view","getBoundingClientRect","absoluteX","absoluteY","left","top","isGestureEnabledForEvent","_ref4","_recognizer","_ref5","minPointers","maxPointers","pointerLength","validPointerCount","isGestureRunning","failed","success"],"sources":["/Users/solomon-moulang-lewis/Documents/University/Year 2/Term 2/User interface design/soen357Project/client/node_modules/react-native-gesture-handler/lib/module/web_hammer/DiscreteGestureHandler.ts"],"sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nabstract class DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY }: any,\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\n        maxDistSq\n      )\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }: any) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\n  ) {\n    const validPointerCount =\n      pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n"],"mappings":"AAAA;;AACA;AACA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,SAASC,mBAAT,QAAoC,SAApC;AAEA,MAAeC,sBAAf,SAA8CF,cAA9C,CAA6D;EAC7C,IAAVG,UAAUA,CAAA,EAAG;IACf,OAAO,IAAP;EACD;EAE6B,IAA1BC,0BAA0BA,CAAA,EAAG;IAC/B,OAAO,IAAP;EACD;EAEDC,6BAA6BA,CAAAC,IAAA,EAAAC,KAAA,EAG3B;IAAA,IAFA;MAAEC,CAAF;MAAKC,CAAL;MAAQC,MAAR;MAAgBC;IAAhB,CAD2B,GAAAL,IAAA;IAAA,IAE3B;MAAEM,SAAF;MAAaC,SAAb;MAAwBC,SAAxB;MAAmCC;IAAnC,CAF2B,GAAAR,KAAA;IAI3B,IAAIQ,uBAAJ,EAA6B;MAC3B,IAAI,CAAC,KAAKC,aAAL,CAAmB;QAAER,CAAF;QAAKC;MAAL,CAAnB,CAAL,EAAmC;QACjC,OAAO,IAAP;MACD;IACF;IACD,OACER,mBAAmB,CAACgB,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,EAAmBE,SAAnB,CAAnB,IACAX,mBAAmB,CAACgB,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,EAAmBE,SAAnB,CADnB,IAEAZ,mBAAmB,CACjBgB,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CADiB,EAEjBI,SAFiB,CAHrB;EAQD;EAEDK,oBAAoBA,CAAAC,KAAA,EAA4B;IAAA,IAA3B;MAAEC,MAAM,EAAE;QAAEb,CAAF;QAAKC;MAAL;IAAV,CAAD,GAAAW,KAAA;IAClB;IACA,MAAME,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;IAEA,OAAO;MACLC,SAAS,EAAEjB,CADN;MAELkB,SAAS,EAAEjB,CAFN;MAGLD,CAAC,EAAEA,CAAC,GAAGc,IAAI,CAACK,IAHP;MAILlB,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACM;IAJP,CAAP;EAMD;EAEDC,wBAAwBA,CAAAC,KAAA,EAStBC,WATsB,EAAAC,KAAA,EAWtB;IAAA,IAVA;MACEC,WADF;MAEEC,WAFF;MAGEtB,SAHF;MAIEC,SAJF;MAKEC,SALF;MAMEC;IANF,CADsB,GAAAe,KAAA;IAAA,IAUtB;MAAEI,WAAW,EAAEC,aAAf;MAA8Bd,MAA9B;MAAsCX,MAAtC;MAA8CC;IAA9C,CAVsB,GAAAqB,KAAA;IAYtB,MAAMI,iBAAiB,GACrBD,aAAa,IAAIF,WAAjB,IAAgCE,aAAa,IAAID,WADnD;IAGA,IACE,KAAK7B,6BAAL,CACE;MAAE,GAAGgB,MAAL;MAAaX,MAAb;MAAqBC;IAArB,CADF,EAEE;MACEC,SADF;MAEEC,SAFF;MAGEC,SAHF;MAIEC;IAJF,CAFF;IASA;IACA;IACC,CAACqB,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;MACA,OAAO;QAAEC,MAAM,EAAE;MAAV,CAAP;IACD;IAED,OAAO;MAAEC,OAAO,EAAEH;IAAX,CAAP;EACD;AAzE0D;AA4E7D,eAAelC,sBAAf"},"metadata":{},"sourceType":"module","externalDependencies":[]}