{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/* eslint-disable react/sort-comp */\nimport * as React from 'react';\nimport { Linking, Platform, BackHandler } from 'react-native';\nimport { NavigationActions, ThemeProvider, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\nconst {\n  urlToPathAndParams\n} = pathUtils;\nfunction isStateful(props) {\n  return !props.navigation;\n}\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  /* eslint-disable no-unused-vars */\n\n  const {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    theme,\n    ...containerProps\n  } = props;\n  /* eslint-enable no-unused-vars */\n\n  const keys = Object.keys(containerProps);\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + \"unclear if it should own its own state. Remove props: \\\"\".concat(keys.join(', '), \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n} // Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\n\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n} // We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\n\nlet _reactNavigationIsHydratingState = false; // Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\n\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n    constructor(props) {\n      super(props);\n      _defineProperty(this, \"subs\", null);\n      _defineProperty(this, \"_actionEventSubscribers\", new Set());\n      _defineProperty(this, \"_handleOpenURL\", _ref => {\n        let {\n          url\n        } = _ref;\n        const {\n          enableURLHandling,\n          uriPrefix\n        } = this.props;\n        if (enableURLHandling === false) {\n          return;\n        }\n        const parsedUrl = urlToPathAndParams(url, uriPrefix);\n        if (parsedUrl) {\n          const {\n            path,\n            params\n          } = parsedUrl;\n          const action = Component.router.getActionForPathAndParams(path, params);\n          if (action) {\n            this.dispatch(action);\n          }\n        }\n      });\n      _defineProperty(this, \"_persistNavigationState\", async nav => {\n        const {\n          persistNavigationState\n        } = this.props;\n        if (persistNavigationState) {\n          try {\n            await persistNavigationState(nav);\n          } catch (err) {\n            console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n          }\n        }\n      });\n      _defineProperty(this, \"dispatch\", action => {\n        if (this.props.navigation) {\n          return this.props.navigation.dispatch(action);\n        } // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n\n        this._navState = this._navState || this.state.nav;\n        const lastNavState = this._navState;\n        invariant(lastNavState, 'should be set in constructor if stateful');\n        const reducedState = Component.router.getStateForAction(action, lastNavState);\n        const navState = reducedState === null ? lastNavState : reducedState;\n        const dispatchActionEvents = () => {\n          this._actionEventSubscribers.forEach(subscriber => subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState\n          }));\n        };\n        if (reducedState === null) {\n          // The router will return null when action has been handled and the state hasn't changed.\n          // dispatch returns true when something has been handled.\n          dispatchActionEvents();\n          return true;\n        }\n        if (navState !== lastNavState) {\n          // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n          this._navState = navState;\n          this.setState({\n            nav: navState\n          }, () => {\n            this._onNavigationStateChange(lastNavState, navState, action);\n            dispatchActionEvents();\n            this._persistNavigationState(navState);\n          });\n          return true;\n        }\n        dispatchActionEvents();\n        return false;\n      });\n      _defineProperty(this, \"_getScreenProps\", () => this.props.screenProps);\n      _defineProperty(this, \"_getTheme\", () => {\n        if (this.props.theme === 'light' || this.props.theme === 'dark') {\n          return this.props.theme;\n        } else if (this.props.theme === 'no-preference') {\n          return 'light';\n        } else {\n          console.warn(\"Invalid theme provided: \".concat(this.props.theme, \". Only 'light' and 'dark' are supported. Falling back to 'light'\"));\n          return 'light';\n        }\n      });\n      validateProps(props);\n      this._initialAction = NavigationActions.init();\n      if (this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n      this.state = {\n        nav: this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(this._initialAction) : null\n      };\n    }\n    _renderLoading() {\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n    }\n    _isStateful() {\n      return isStateful(this.props);\n    }\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav\n          });\n        }\n        return;\n      }\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n      if (process.env.NODE_ENV !== 'production' && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \".concat(docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')));\n          }\n        }\n      }\n      _statefulContainerCount++;\n      this._linkingSub = Linking.addEventListener('url', this._handleOpenURL); // Pull out anything that can impact state\n\n      let parsedUrl = null;\n      let userProvidedStartupState = null;\n      if (this.props.enableURLHandling !== false) {\n        ({\n          parsedUrl,\n          userProvidedStartupState\n        } = await this.getStartupParams());\n      } // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n\n      let action = this._initialAction; // eslint-disable-next-line react/no-access-state-in-setstate\n\n      let startupState = this.state.nav;\n      if (!startupState && !userProvidedStartupState) {\n        !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      } // Pull user-provided persisted state\n\n      if (userProvidedStartupState) {\n        startupState = userProvidedStartupState;\n        _reactNavigationIsHydratingState = true;\n      } // Pull state out of URL\n\n      if (parsedUrl) {\n        const {\n          path,\n          params\n        } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(path, params);\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n          action = urlAction;\n          startupState = Component.router.getStateForAction(urlAction, startupState);\n        }\n      }\n      const dispatchActions = () => this._actionEventSubscribers.forEach(subscriber => subscriber({\n        type: 'action',\n        action,\n        state: this.state.nav,\n        lastState: null\n      }));\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      } // eslint-disable-next-line react/no-did-mount-set-state\n\n      this.setState({\n        nav: startupState\n      }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n    async getStartupParams() {\n      const {\n        uriPrefix,\n        loadNavigationState\n      } = this.props;\n      let url, loadedNavState;\n      try {\n        [url, loadedNavState] = await Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\n      } catch (err) {// ignore\n      }\n      return {\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n        userProvidedStartupState: loadedNavState\n      };\n    }\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n    componentWillUnmount() {\n      var _this$_linkingSub;\n      this._isMounted = false; // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7\n\n      if ((_this$_linkingSub = this._linkingSub) === null || _this$_linkingSub === void 0 ? void 0 : _this$_linkingSub.remove) {\n        var _this$_linkingSub2;\n        (_this$_linkingSub2 = this._linkingSub) === null || _this$_linkingSub2 === void 0 ? void 0 : _this$_linkingSub2.remove();\n      } else {\n        Linking.removeEventListener('url', this._handleOpenURL);\n      }\n      this.subs && this.subs.remove();\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    } // Per-tick temporary storage for state.nav\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n      return /*#__PURE__*/React.createElement(ThemeProvider, {\n        value: this._getTheme()\n      }, /*#__PURE__*/React.createElement(NavigationProvider, {\n        value: navigation\n      }, /*#__PURE__*/React.createElement(Component, _extends({}, this.props, {\n        navigation: navigation\n      }))));\n    }\n  }\n  _defineProperty(NavigationContainer, \"router\", Component.router);\n  _defineProperty(NavigationContainer, \"navigationOptions\", null);\n  _defineProperty(NavigationContainer, \"defaultProps\", {\n    theme: 'light'\n  });\n  return NavigationContainer;\n}","map":{"version":3,"names":["React","Linking","Platform","BackHandler","NavigationActions","ThemeProvider","pathUtils","getNavigation","NavigationProvider","invariant","docsUrl","urlToPathAndParams","isStateful","props","navigation","validateProps","persistenceKey","console","warn","screenProps","persistNavigationState","loadNavigationState","theme","containerProps","keys","Object","length","Error","concat","join","undefined","_statefulContainerCount","_TESTING_ONLY_reset_container_count","_reactNavigationIsHydratingState","createNavigationContainer","Component","NavigationContainer","getDerivedStateFromProps","nextProps","constructor","_defineProperty","Set","_ref","url","enableURLHandling","uriPrefix","parsedUrl","path","params","action","router","getActionForPathAndParams","dispatch","nav","err","_navState","state","lastNavState","reducedState","getStateForAction","navState","dispatchActionEvents","_actionEventSubscribers","forEach","subscriber","type","lastState","setState","_onNavigationStateChange","_persistNavigationState","_initialAction","init","_isStateful","addEventListener","subs","_isMounted","remove","back","_renderLoading","renderLoadingExperimental","prevNav","onNavigationStateChange","process","env","REACT_NAV_LOGGING","group","log","groupEnd","newState","componentDidUpdate","componentDidMount","NODE_ENV","detached","OS","_linkingSub","_handleOpenURL","userProvidedStartupState","getStartupParams","startupState","urlAction","dispatchActions","loadedNavState","Promise","all","getInitialURL","componentDidCatch","e","componentWillUnmount","_this$_linkingSub","_this$_linkingSub2","removeEventListener","render","_navigation","_getScreenProps","createElement","value","_getTheme","_extends"],"sources":["/Users/solomon-moulang-lewis/Documents/University/Year 2/Term 2/User interface design/soen357Project/client/node_modules/@react-navigation/native/lib/module/createAppContainer.js"],"sourcesContent":["/* eslint-disable react/sort-comp */\n\nimport * as React from 'react';\nimport { Linking, Platform, BackHandler } from 'react-native';\nimport {\n  NavigationActions,\n  ThemeProvider,\n  pathUtils,\n  getNavigation,\n  NavigationProvider,\n} from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\n\nconst { urlToPathAndParams } = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn(\n      'You passed persistenceKey prop to a navigator. ' +\n        'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' +\n        'please see the navigation state persistence docs for more information. ' +\n        'Passing the persistenceKey prop is a no-op.'\n    );\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  /* eslint-disable no-unused-vars */\n  const {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    theme,\n    ...containerProps\n  } = props;\n  /* eslint-enable no-unused-vars */\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error(\n      'This navigator has both navigation and container props, so it is ' +\n        `unclear if it should own its own state. Remove props: \"${keys.join(\n          ', '\n        )}\" ` +\n        'if the navigator should get its state from the navigation prop. If the ' +\n        'navigator should maintain its own state, do not pass a navigation prop.'\n    );\n  }\n  invariant(\n    (persistNavigationState === undefined &&\n      loadNavigationState === undefined) ||\n      (typeof persistNavigationState === 'function' &&\n        typeof loadNavigationState === 'function'),\n    'both persistNavigationState and loadNavigationState must either be undefined, or be functions'\n  );\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static defaultProps = {\n      theme: 'light',\n    };\n\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (\n        this._isStateful() &&\n        BackHandler &&\n        typeof BackHandler.addEventListener === 'function'\n      ) {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav:\n          this._isStateful() && !props.loadNavigationState\n            ? Component.router.getStateForAction(this._initialAction)\n            : null,\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental\n        ? this.props.renderLoadingExperimental()\n        : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const { enableURLHandling, uriPrefix } = this.props;\n      if (enableURLHandling === false) {\n        return;\n      }\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (\n        typeof this.props.onNavigationStateChange === 'undefined' &&\n        this._isStateful() &&\n        !!process.env.REACT_NAV_LOGGING\n      ) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav,\n          });\n        }\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(\n              `You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl(\n                'common-mistakes.html#explicitly-rendering-more-than-one-navigator'\n              )}`\n            );\n          }\n        }\n      }\n      _statefulContainerCount++;\n      this._linkingSub = Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      let parsedUrl = null;\n      let userProvidedStartupState = null;\n      if (this.props.enableURLHandling !== false) {\n        ({\n          parsedUrl,\n          userProvidedStartupState,\n        } = await this.getStartupParams());\n      }\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      // eslint-disable-next-line react/no-access-state-in-setstate\n      let startupState = this.state.nav;\n      if (!startupState && !userProvidedStartupState) {\n        !!process.env.REACT_NAV_LOGGING &&\n          console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull user-provided persisted state\n      if (userProvidedStartupState) {\n        startupState = userProvidedStartupState;\n        _reactNavigationIsHydratingState = true;\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(\n          path,\n          params\n        );\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING &&\n            console.log(\n              'Applying Navigation Action for Initial URL:',\n              parsedUrl\n            );\n          action = urlAction;\n          startupState = Component.router.getStateForAction(\n            urlAction,\n            startupState\n          );\n        }\n      }\n\n      const dispatchActions = () =>\n        this._actionEventSubscribers.forEach((subscriber) =>\n          subscriber({\n            type: 'action',\n            action,\n            state: this.state.nav,\n            lastState: null,\n          })\n        );\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    async getStartupParams() {\n      const { uriPrefix, loadNavigationState } = this.props;\n      let url, loadedNavState;\n      try {\n        [url, loadedNavState] = await Promise.all([\n          Linking.getInitialURL(),\n          loadNavigationState && loadNavigationState(),\n        ]);\n      } catch (err) {\n        // ignore\n      }\n      return {\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n        userProvidedStartupState: loadedNavState,\n      };\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn(\n          'Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...'\n        );\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    _persistNavigationState = async (nav) => {\n      const { persistNavigationState } = this.props;\n      if (persistNavigationState) {\n        try {\n          await persistNavigationState(nav);\n        } catch (err) {\n          console.warn(\n            'Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.'\n          );\n        }\n      }\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n\n      // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7\n      if (this._linkingSub?.remove) {\n        this._linkingSub?.remove();\n      } else {\n        Linking.removeEventListener('url', this._handleOpenURL);\n      }\n\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = (action) => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(\n        action,\n        lastNavState\n      );\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach((subscriber) =>\n          subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState,\n          })\n        );\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    _getScreenProps = () => this.props.screenProps;\n\n    _getTheme = () => {\n      if (this.props.theme === 'light' || this.props.theme === 'dark') {\n        return this.props.theme;\n      } else if (this.props.theme === 'no-preference') {\n        return 'light';\n      } else {\n        console.warn(\n          `Invalid theme provided: ${this.props.theme}. Only 'light' and 'dark' are supported. Falling back to 'light'`\n        );\n        return 'light';\n      }\n    };\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(\n            Component.router,\n            navState,\n            this.dispatch,\n            this._actionEventSubscribers,\n            this._getScreenProps,\n            () => this._navigation\n          );\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n\n      return (\n        <ThemeProvider value={this._getTheme()}>\n          <NavigationProvider value={navigation}>\n            <Component {...this.props} navigation={navigation} />\n          </NavigationProvider>\n        </ThemeProvider>\n      );\n    }\n  }\n\n  return NavigationContainer;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}