{"ast":null,"code":"import getChildRouter from './getChildRouter';\nimport getNavigationActionCreators from './routers/getNavigationActionCreators';\nimport getChildrenNavigationCache from './getChildrenNavigationCache';\nimport getEventManager from './getEventManager';\nconst createParamGetter = route => (paramName, defaultValue) => {\n  const params = route.params;\n  if (params && paramName in params) {\n    return params[paramName];\n  }\n  return defaultValue;\n};\nfunction getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  const children = getChildrenNavigationCache(navigation);\n  const childRoute = navigation.state.routes.find(r => r.key === childKey);\n  if (!childRoute) {\n    return null;\n  }\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n  const childRouter = getChildRouter(navigation.router, childRoute.routeName); // If the route has children, we'll use this to pass in to the action creators\n  // for the childRouter so that any action that depends on the active route will\n  // behave as expected. We don't explicitly require that routers implement routes\n  // and index properties, but if we did then we would put an invariant here to\n  // ensure that a focusedGrandChildRoute exists if childRouter is defined.\n\n  const focusedGrandChildRoute = childRoute.routes && typeof childRoute.index === 'number' ? childRoute.routes[childRoute.index] : null;\n  const actionCreators = {\n    ...navigation.actions,\n    ...navigation.router.getActionCreators(childRoute, navigation.state.key),\n    ...(childRouter ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key) : {}),\n    ...getNavigationActionCreators(childRoute)\n  };\n  const actionHelpers = {};\n  Object.keys(actionCreators).forEach(actionName => {\n    actionHelpers[actionName] = function () {\n      const actionCreator = actionCreators[actionName];\n      const action = actionCreator(...arguments);\n      return navigation.dispatch(action);\n    };\n  });\n  let isFirstRouteInParent = true;\n  const parentNavigation = getCurrentParentNavigation();\n  if (parentNavigation) {\n    isFirstRouteInParent = parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n  if (children[childKey] && children[childKey].isFirstRouteInParent() === isFirstRouteInParent) {\n    children[childKey] = {\n      ...children[childKey],\n      ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute)\n    };\n    return children[childKey];\n  } else {\n    const {\n      addListener,\n      emit\n    } = getEventManager(childKey);\n    children[childKey] = {\n      ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n      getChildNavigation: grandChildKey => getChildNavigation(children[childKey], grandChildKey, () => {\n        const nav = getCurrentParentNavigation();\n        return nav && nav.getChildNavigation(childKey);\n      }),\n      isFocused: () => {\n        const currentNavigation = getCurrentParentNavigation();\n        if (!currentNavigation) {\n          return false;\n        }\n        const {\n          routes,\n          index\n        } = currentNavigation.state;\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n        if (routes[index].key === childKey) {\n          return true;\n        }\n        return false;\n      },\n      isFirstRouteInParent: () => isFirstRouteInParent,\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener,\n      emit\n    };\n    return children[childKey];\n  }\n}\nexport default getChildNavigation;","map":{"version":3,"names":["getChildRouter","getNavigationActionCreators","getChildrenNavigationCache","getEventManager","createParamGetter","route","paramName","defaultValue","params","getChildNavigation","navigation","childKey","getCurrentParentNavigation","children","childRoute","state","routes","find","r","key","childRouter","router","routeName","focusedGrandChildRoute","index","actionCreators","actions","getActionCreators","actionHelpers","Object","keys","forEach","actionName","actionCreator","action","arguments","dispatch","isFirstRouteInParent","parentNavigation","indexOf","getParam","addListener","emit","grandChildKey","nav","isFocused","currentNavigation","getScreenProps","dangerouslyGetParent"],"sources":["/Users/solomon-moulang-lewis/Documents/University/Year 2/Term 2/User interface design/soen357Project/client/node_modules/@react-navigation/core/lib/module/getChildNavigation.js"],"sourcesContent":["import getChildRouter from './getChildRouter';\nimport getNavigationActionCreators from './routers/getNavigationActionCreators';\nimport getChildrenNavigationCache from './getChildrenNavigationCache';\nimport getEventManager from './getEventManager';\n\nconst createParamGetter = (route) => (paramName, defaultValue) => {\n  const params = route.params;\n\n  if (params && paramName in params) {\n    return params[paramName];\n  }\n\n  return defaultValue;\n};\n\nfunction getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  const children = getChildrenNavigationCache(navigation);\n  const childRoute = navigation.state.routes.find((r) => r.key === childKey);\n\n  if (!childRoute) {\n    return null;\n  }\n\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n\n  const childRouter = getChildRouter(navigation.router, childRoute.routeName);\n\n  // If the route has children, we'll use this to pass in to the action creators\n  // for the childRouter so that any action that depends on the active route will\n  // behave as expected. We don't explicitly require that routers implement routes\n  // and index properties, but if we did then we would put an invariant here to\n  // ensure that a focusedGrandChildRoute exists if childRouter is defined.\n  const focusedGrandChildRoute =\n    childRoute.routes && typeof childRoute.index === 'number'\n      ? childRoute.routes[childRoute.index]\n      : null;\n\n  const actionCreators = {\n    ...navigation.actions,\n    ...navigation.router.getActionCreators(childRoute, navigation.state.key),\n    ...(childRouter\n      ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key)\n      : {}),\n    ...getNavigationActionCreators(childRoute),\n  };\n\n  const actionHelpers = {};\n  Object.keys(actionCreators).forEach((actionName) => {\n    actionHelpers[actionName] = (...args) => {\n      const actionCreator = actionCreators[actionName];\n      const action = actionCreator(...args);\n      return navigation.dispatch(action);\n    };\n  });\n\n  let isFirstRouteInParent = true;\n\n  const parentNavigation = getCurrentParentNavigation();\n\n  if (parentNavigation) {\n    isFirstRouteInParent =\n      parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n\n  if (\n    children[childKey] &&\n    children[childKey].isFirstRouteInParent() === isFirstRouteInParent\n  ) {\n    children[childKey] = {\n      ...children[childKey],\n      ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n    };\n    return children[childKey];\n  } else {\n    const { addListener, emit } = getEventManager(childKey);\n\n    children[childKey] = {\n      ...actionHelpers,\n\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n\n      getChildNavigation: (grandChildKey) =>\n        getChildNavigation(children[childKey], grandChildKey, () => {\n          const nav = getCurrentParentNavigation();\n          return nav && nav.getChildNavigation(childKey);\n        }),\n\n      isFocused: () => {\n        const currentNavigation = getCurrentParentNavigation();\n        if (!currentNavigation) {\n          return false;\n        }\n        const { routes, index } = currentNavigation.state;\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n        if (routes[index].key === childKey) {\n          return true;\n        }\n        return false;\n      },\n      isFirstRouteInParent: () => isFirstRouteInParent,\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener,\n      emit,\n    };\n\n    return children[childKey];\n  }\n}\n\nexport default getChildNavigation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}