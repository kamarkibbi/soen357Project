{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { State } from '../../State';\nimport { Direction } from '../constants';\nimport GestureHandler from './GestureHandler';\nconst DEFAULT_MAX_DURATION_MS = 800;\nconst DEFAULT_MIN_ACCEPTABLE_DELTA = 160;\nconst DEFAULT_DIRECTION = Direction.RIGHT;\nconst DEFAULT_NUMBER_OF_TOUCHES_REQUIRED = 1;\nexport default class FlingGestureHandler extends GestureHandler {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"numberOfPointersRequired\", DEFAULT_NUMBER_OF_TOUCHES_REQUIRED);\n    _defineProperty(this, \"direction\", DEFAULT_DIRECTION);\n    _defineProperty(this, \"maxDurationMs\", DEFAULT_MAX_DURATION_MS);\n    _defineProperty(this, \"minAcceptableDelta\", DEFAULT_MIN_ACCEPTABLE_DELTA);\n    _defineProperty(this, \"delayTimeout\", void 0);\n    _defineProperty(this, \"startX\", 0);\n    _defineProperty(this, \"startY\", 0);\n    _defineProperty(this, \"maxNumberOfPointersSimultaneously\", 0);\n    _defineProperty(this, \"keyPointer\", NaN);\n  }\n  init(ref, propsRef) {\n    super.init(ref, propsRef);\n  }\n  updateGestureConfig(_ref) {\n    let {\n      enabled = true,\n      ...props\n    } = _ref;\n    super.updateGestureConfig({\n      enabled: enabled,\n      ...props\n    });\n    if (this.config.direction) {\n      this.direction = this.config.direction;\n    }\n    if (this.config.numberOfPointers) {\n      this.numberOfPointersRequired = this.config.numberOfPointers;\n    }\n  }\n  transformNativeEvent() {\n    const rect = this.view.getBoundingClientRect();\n    return {\n      x: this.tracker.getLastAvgX() - rect.left,\n      y: this.tracker.getLastAvgY() - rect.top,\n      absoluteX: this.tracker.getLastAvgX(),\n      absoluteY: this.tracker.getLastAvgY()\n    };\n  }\n  startFling() {\n    this.startX = this.tracker.getLastX(this.keyPointer);\n    this.startY = this.tracker.getLastY(this.keyPointer);\n    this.begin();\n    this.maxNumberOfPointersSimultaneously = 1;\n    this.delayTimeout = setTimeout(() => this.fail(), this.maxDurationMs);\n  }\n  tryEndFling() {\n    if (this.maxNumberOfPointersSimultaneously === this.numberOfPointersRequired && (this.direction & Direction.RIGHT && this.tracker.getLastX(this.keyPointer) - this.startX > this.minAcceptableDelta || this.direction & Direction.LEFT && this.startX - this.tracker.getLastX(this.keyPointer) > this.minAcceptableDelta || this.direction & Direction.UP && this.startY - this.tracker.getLastY(this.keyPointer) > this.minAcceptableDelta || this.direction & Direction.DOWN && this.tracker.getLastY(this.keyPointer) - this.startY > this.minAcceptableDelta)) {\n      clearTimeout(this.delayTimeout);\n      this.activate();\n      return true;\n    }\n    return false;\n  }\n  endFling() {\n    if (!this.tryEndFling()) {\n      this.fail();\n    }\n  }\n  onPointerDown(event) {\n    this.tracker.addToTracker(event);\n    this.keyPointer = event.pointerId;\n    super.onPointerDown(event);\n    this.newPointerAction();\n  }\n  onPointerAdd(event) {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.newPointerAction();\n  }\n  newPointerAction() {\n    if (this.currentState === State.UNDETERMINED) {\n      this.startFling();\n    }\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n    this.tryEndFling();\n    if (this.tracker.getTrackedPointersCount() > this.maxNumberOfPointersSimultaneously) {\n      this.maxNumberOfPointersSimultaneously = this.tracker.getTrackedPointersCount();\n    }\n  }\n  onPointerMove(event) {\n    this.tracker.track(event);\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n    this.tryEndFling();\n    super.onPointerMove(event);\n  }\n  onPointerUp(event) {\n    super.onPointerUp(event);\n    this.onUp(event);\n    this.keyPointer = NaN;\n  }\n  onPointerRemove(event) {\n    super.onPointerRemove(event);\n    this.onUp(event);\n  }\n  onUp(event) {\n    this.tracker.removeFromTracker(event.pointerId);\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n    this.endFling();\n  }\n  onPointerCancel(event) {\n    super.onPointerCancel(event);\n    this.reset();\n  }\n  activate(force) {\n    super.activate(force);\n    this.end();\n  }\n  resetConfig() {\n    super.resetConfig();\n    this.numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n    this.direction = DEFAULT_DIRECTION;\n  }\n}","map":{"version":3,"names":["State","Direction","GestureHandler","DEFAULT_MAX_DURATION_MS","DEFAULT_MIN_ACCEPTABLE_DELTA","DEFAULT_DIRECTION","RIGHT","DEFAULT_NUMBER_OF_TOUCHES_REQUIRED","FlingGestureHandler","constructor","arguments","_defineProperty","NaN","init","ref","propsRef","updateGestureConfig","_ref","enabled","props","config","direction","numberOfPointers","numberOfPointersRequired","transformNativeEvent","rect","view","getBoundingClientRect","x","tracker","getLastAvgX","left","y","getLastAvgY","top","absoluteX","absoluteY","startFling","startX","getLastX","keyPointer","startY","getLastY","begin","maxNumberOfPointersSimultaneously","delayTimeout","setTimeout","fail","maxDurationMs","tryEndFling","minAcceptableDelta","LEFT","UP","DOWN","clearTimeout","activate","endFling","onPointerDown","event","addToTracker","pointerId","newPointerAction","onPointerAdd","currentState","UNDETERMINED","BEGAN","getTrackedPointersCount","onPointerMove","track","onPointerUp","onUp","onPointerRemove","removeFromTracker","onPointerCancel","reset","force","end","resetConfig"],"sources":["/Users/solomon-moulang-lewis/Documents/University/Year 2/Term 2/User interface design/soen357Project/client/node_modules/react-native-gesture-handler/lib/module/web/handlers/FlingGestureHandler.ts"],"sourcesContent":["import { State } from '../../State';\nimport { Direction } from '../constants';\nimport { AdaptedEvent, Config } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\n\nconst DEFAULT_MAX_DURATION_MS = 800;\nconst DEFAULT_MIN_ACCEPTABLE_DELTA = 160;\nconst DEFAULT_DIRECTION = Direction.RIGHT;\nconst DEFAULT_NUMBER_OF_TOUCHES_REQUIRED = 1;\n\nexport default class FlingGestureHandler extends GestureHandler {\n  private numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n  private direction = DEFAULT_DIRECTION;\n\n  private maxDurationMs = DEFAULT_MAX_DURATION_MS;\n  private minAcceptableDelta = DEFAULT_MIN_ACCEPTABLE_DELTA;\n  private delayTimeout!: number;\n\n  private startX = 0;\n  private startY = 0;\n\n  private maxNumberOfPointersSimultaneously = 0;\n  private keyPointer = NaN;\n\n  public init(ref: number, propsRef: React.RefObject<unknown>): void {\n    super.init(ref, propsRef);\n  }\n\n  public updateGestureConfig({ enabled = true, ...props }: Config): void {\n    super.updateGestureConfig({ enabled: enabled, ...props });\n\n    if (this.config.direction) {\n      this.direction = this.config.direction;\n    }\n\n    if (this.config.numberOfPointers) {\n      this.numberOfPointersRequired = this.config.numberOfPointers;\n    }\n  }\n\n  protected transformNativeEvent() {\n    const rect: DOMRect = this.view.getBoundingClientRect();\n\n    return {\n      x: this.tracker.getLastAvgX() - rect.left,\n      y: this.tracker.getLastAvgY() - rect.top,\n      absoluteX: this.tracker.getLastAvgX(),\n      absoluteY: this.tracker.getLastAvgY(),\n    };\n  }\n\n  private startFling(): void {\n    this.startX = this.tracker.getLastX(this.keyPointer);\n    this.startY = this.tracker.getLastY(this.keyPointer);\n\n    this.begin();\n\n    this.maxNumberOfPointersSimultaneously = 1;\n\n    this.delayTimeout = setTimeout(() => this.fail(), this.maxDurationMs);\n  }\n\n  private tryEndFling(): boolean {\n    if (\n      this.maxNumberOfPointersSimultaneously ===\n        this.numberOfPointersRequired &&\n      ((this.direction & Direction.RIGHT &&\n        this.tracker.getLastX(this.keyPointer) - this.startX >\n          this.minAcceptableDelta) ||\n        (this.direction & Direction.LEFT &&\n          this.startX - this.tracker.getLastX(this.keyPointer) >\n            this.minAcceptableDelta) ||\n        (this.direction & Direction.UP &&\n          this.startY - this.tracker.getLastY(this.keyPointer) >\n            this.minAcceptableDelta) ||\n        (this.direction & Direction.DOWN &&\n          this.tracker.getLastY(this.keyPointer) - this.startY >\n            this.minAcceptableDelta))\n    ) {\n      clearTimeout(this.delayTimeout);\n      this.activate();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private endFling() {\n    if (!this.tryEndFling()) {\n      this.fail();\n    }\n  }\n\n  protected onPointerDown(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    this.keyPointer = event.pointerId;\n\n    super.onPointerDown(event);\n    this.newPointerAction();\n  }\n\n  protected onPointerAdd(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.newPointerAction();\n  }\n\n  private newPointerAction(): void {\n    if (this.currentState === State.UNDETERMINED) {\n      this.startFling();\n    }\n\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n\n    this.tryEndFling();\n\n    if (\n      this.tracker.getTrackedPointersCount() >\n      this.maxNumberOfPointersSimultaneously\n    ) {\n      this.maxNumberOfPointersSimultaneously =\n        this.tracker.getTrackedPointersCount();\n    }\n  }\n\n  protected onPointerMove(event: AdaptedEvent): void {\n    this.tracker.track(event);\n\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n\n    this.tryEndFling();\n\n    super.onPointerMove(event);\n  }\n\n  protected onPointerUp(event: AdaptedEvent): void {\n    super.onPointerUp(event);\n    this.onUp(event);\n\n    this.keyPointer = NaN;\n  }\n\n  protected onPointerRemove(event: AdaptedEvent): void {\n    super.onPointerRemove(event);\n    this.onUp(event);\n  }\n\n  private onUp(event: AdaptedEvent): void {\n    this.tracker.removeFromTracker(event.pointerId);\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n    this.endFling();\n  }\n\n  protected onPointerCancel(event: AdaptedEvent): void {\n    super.onPointerCancel(event);\n    this.reset();\n  }\n\n  public activate(force?: boolean): void {\n    super.activate(force);\n    this.end();\n  }\n\n  protected resetConfig(): void {\n    super.resetConfig();\n    this.numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n    this.direction = DEFAULT_DIRECTION;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}