{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport default class EventManager {\n  constructor(view) {\n    _defineProperty(this, \"view\", void 0);\n    _defineProperty(this, \"pointersInBounds\", []);\n    _defineProperty(this, \"activePointersCounter\", void 0);\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n  onPointerDown(_event) {}\n  onPointerAdd(_event) {}\n  onPointerUp(_event) {}\n  onPointerRemove(_event) {}\n  onPointerMove(_event) {}\n  onPointerOut(_event) {}\n  onPointerEnter(_event) {}\n  onPointerCancel(_event) {// When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  onPointerOutOfBounds(_event) {}\n  setOnPointerDown(callback) {\n    this.onPointerDown = callback;\n  }\n  setOnPointerAdd(callback) {\n    this.onPointerAdd = callback;\n  }\n  setOnPointerUp(callback) {\n    this.onPointerUp = callback;\n  }\n  setOnPointerRemove(callback) {\n    this.onPointerRemove = callback;\n  }\n  setOnPointerMove(callback) {\n    this.onPointerMove = callback;\n  }\n  setOnPointerOut(callback) {\n    this.onPointerOut = callback;\n  }\n  setOnPointerEnter(callback) {\n    this.onPointerEnter = callback;\n  }\n  setOnPointerCancel(callback) {\n    this.onPointerCancel = callback;\n  }\n  setOnPointerOutOfBounds(callback) {\n    this.onPointerOutOfBounds = callback;\n  }\n  markAsInBounds(pointerId) {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n    this.pointersInBounds.push(pointerId);\n  }\n  markAsOutOfBounds(pointerId) {\n    const index = this.pointersInBounds.indexOf(pointerId);\n    if (index < 0) {\n      return;\n    }\n    this.pointersInBounds.splice(index, 1);\n  }\n  resetManager() {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}","map":{"version":3,"names":["EventManager","constructor","view","_defineProperty","activePointersCounter","onPointerDown","_event","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerOut","onPointerEnter","onPointerCancel","onPointerOutOfBounds","setOnPointerDown","callback","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerOut","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","markAsInBounds","pointerId","pointersInBounds","indexOf","push","markAsOutOfBounds","index","splice","resetManager"],"sources":["/Users/solomon-moulang-lewis/Documents/University/Year 2/Term 2/User interface design/soen357Project/client/node_modules/react-native-gesture-handler/lib/module/web/tools/EventManager.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\n\nexport default abstract class EventManager {\n  protected readonly view: HTMLElement;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: HTMLElement) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract setListeners(): void;\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes,\n    index?: number,\n    touchEventType?: TouchEventType\n  ): AdaptedEvent;\n\n  protected onPointerDown(_event: AdaptedEvent): void {}\n  protected onPointerAdd(_event: AdaptedEvent): void {}\n  protected onPointerUp(_event: AdaptedEvent): void {}\n  protected onPointerRemove(_event: AdaptedEvent): void {}\n  protected onPointerMove(_event: AdaptedEvent): void {}\n  protected onPointerOut(_event: AdaptedEvent): void {}\n  protected onPointerEnter(_event: AdaptedEvent): void {}\n  protected onPointerCancel(_event: AdaptedEvent): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(_event: AdaptedEvent): void {}\n\n  public setOnPointerDown(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerOut(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerOut = callback;\n  }\n  public setOnPointerEnter(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(\n    callback: (event: AdaptedEvent) => void\n  ): void {\n    this.onPointerOutOfBounds = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;AAAA;AAGA,eAAe,MAAeA,YAAf,CAA4B;EAKzCC,WAAWA,CAACC,IAAD,EAAoB;IAAAC,eAAA;IAAAA,eAAA,2BAHQ,EAGR;IAAAA,eAAA;IAC7B,KAAKD,IAAL,GAAYA,IAAZ;IACA,KAAKE,qBAAL,GAA6B,CAA7B;EACD;EAUSC,aAAaA,CAACC,MAAD,EAA6B,CAAE;EAC5CC,YAAYA,CAACD,MAAD,EAA6B,CAAE;EAC3CE,WAAWA,CAACF,MAAD,EAA6B,CAAE;EAC1CG,eAAeA,CAACH,MAAD,EAA6B,CAAE;EAC9CI,aAAaA,CAACJ,MAAD,EAA6B,CAAE;EAC5CK,YAAYA,CAACL,MAAD,EAA6B,CAAE;EAC3CM,cAAcA,CAACN,MAAD,EAA6B,CAAE;EAC7CO,eAAeA,CAACP,MAAD,EAA6B,CACpD;IACA;IACA;IACA;EAAA;EAEQQ,oBAAoBA,CAACR,MAAD,EAA6B,CAAE;EAEtDS,gBAAgBA,CAACC,QAAD,EAAgD;IACrE,KAAKX,aAAL,GAAqBW,QAArB;EACD;EACMC,eAAeA,CAACD,QAAD,EAAgD;IACpE,KAAKT,YAAL,GAAoBS,QAApB;EACD;EACME,cAAcA,CAACF,QAAD,EAAgD;IACnE,KAAKR,WAAL,GAAmBQ,QAAnB;EACD;EACMG,kBAAkBA,CAACH,QAAD,EAAgD;IACvE,KAAKP,eAAL,GAAuBO,QAAvB;EACD;EACMI,gBAAgBA,CAACJ,QAAD,EAAgD;IACrE,KAAKN,aAAL,GAAqBM,QAArB;EACD;EACMK,eAAeA,CAACL,QAAD,EAAgD;IACpE,KAAKL,YAAL,GAAoBK,QAApB;EACD;EACMM,iBAAiBA,CAACN,QAAD,EAAgD;IACtE,KAAKJ,cAAL,GAAsBI,QAAtB;EACD;EACMO,kBAAkBA,CAACP,QAAD,EAAgD;IACvE,KAAKH,eAAL,GAAuBG,QAAvB;EACD;EACMQ,uBAAuBA,CAC5BR,QAD4B,EAEtB;IACN,KAAKF,oBAAL,GAA4BE,QAA5B;EACD;EAESS,cAAcA,CAACC,SAAD,EAA0B;IAChD,IAAI,KAAKC,gBAAL,CAAsBC,OAAtB,CAA8BF,SAA9B,KAA4C,CAAhD,EAAmD;MACjD;IACD;IAED,KAAKC,gBAAL,CAAsBE,IAAtB,CAA2BH,SAA3B;EACD;EAESI,iBAAiBA,CAACJ,SAAD,EAA0B;IACnD,MAAMK,KAAa,GAAG,KAAKJ,gBAAL,CAAsBC,OAAtB,CAA8BF,SAA9B,CAAtB;IAEA,IAAIK,KAAK,GAAG,CAAZ,EAAe;MACb;IACD;IAED,KAAKJ,gBAAL,CAAsBK,MAAtB,CAA6BD,KAA7B,EAAoC,CAApC;EACD;EAEME,YAAYA,CAAA,EAAS;IAC1B;IACA;IACA;IACA;IACA;IACA;IAEA,KAAK7B,qBAAL,GAA6B,CAA7B;IACA,KAAKuB,gBAAL,GAAwB,EAAxB;EACD;AA3FwC"},"metadata":{},"sourceType":"module","externalDependencies":[]}